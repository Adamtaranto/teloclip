name: Update CITATION.cff on Tag
on:
  push:
    tags:
      - '*'
env:
  # Set this to true to see debug output
  DEBUG: false
jobs:
  update-citation:
    runs-on: ubuntu-latest
    # Skip if the last commit was made by this action to prevent infinite loops
    if: |
      github.event.head_commit.author.name != 'github-actions[bot]' &&
      github.event.head_commit.author.email != 'github-actions[bot]@users.noreply.github.com'
    permissions:
      contents: write
    steps:
      - name: Checkout repository at tag
        uses: actions/checkout@v5
        with:
          # Fetch all history for all tags and branches
          fetch-depth: 0
          # Use PAT if available for better permissions, otherwise use GITHUB_TOKEN
          token: ${{ secrets.CITATION_UPDATE_PAT || secrets.GITHUB_TOKEN }}
      - name: Validate CITATION.cff exists
        run: |
          if [ ! -f "CITATION.cff" ]; then
            echo "::error::CITATION.cff file not found in repository root"
            exit 1
          fi
      - name: Get tag information
        id: tag_info
        run: |
          # Get the tag name (version)
          TAG_NAME=$(git describe --tags --abbrev=0)
          echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT

          # Get the date of the tag in YYYY-MM-DD format
          TAG_DATE=$(git log -1 --format="%ad" --date=format:%Y-%m-%d "${TAG_NAME}")
          echo "tag_date=${TAG_DATE}" >> $GITHUB_OUTPUT

          # Remove 'v' prefix if present for version
          TAG_VERSION=${TAG_NAME#v}
          echo "tag_version=${TAG_VERSION}" >> $GITHUB_OUTPUT

          # Function to increment patch version
          increment_patch_version() {
            local version=$1
            # Split version into parts (assumes semantic versioning: major.minor.patch)
            if [[ $version =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              local major=${BASH_REMATCH[1]}
              local minor=${BASH_REMATCH[2]}
              local patch=${BASH_REMATCH[3]}
              local new_patch=$((patch + 1))
              echo "${major}.${minor}.${new_patch}"
            else
              echo "::error::Invalid version format: ${version}"
              exit 1
            fi
          }

          # Calculate incremented version
          INCREMENTED_VERSION=$(increment_patch_version "${TAG_VERSION}")
          echo "incremented_version=${INCREMENTED_VERSION}" >> $GITHUB_OUTPUT

          # Create incremented tag name (preserve 'v' prefix if original had it)
          if [[ "${TAG_NAME}" =~ ^v ]]; then
            INCREMENTED_TAG_NAME="v${INCREMENTED_VERSION}"
          else
            INCREMENTED_TAG_NAME="${INCREMENTED_VERSION}"
          fi
          echo "incremented_tag_name=${INCREMENTED_TAG_NAME}" >> $GITHUB_OUTPUT

          echo "::notice::Processing tag: ${TAG_NAME} (version: ${TAG_VERSION}, created on ${TAG_DATE})"
          echo "::notice::If update needed, will create: ${INCREMENTED_TAG_NAME} (version: ${INCREMENTED_VERSION})"
      - name: Parse current CITATION.cff
        id: parse_citation
        run: |
          # Function to safely extract field value
          extract_field() {
            local field=$1
            local file=$2
            grep -E "^${field}:" "${file}" | sed "s/^${field}:[[:space:]]*//" | sed 's/^"//;s/"$//' | head -1
          }

          # Extract current values
          CURRENT_VERSION=$(extract_field "version" "CITATION.cff")
          CURRENT_DATE=$(extract_field "date-released" "CITATION.cff")

          # Save to outputs
          echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          echo "current_date=${CURRENT_DATE}" >> $GITHUB_OUTPUT

          # Debug output
          if [ "${{ env.DEBUG }}" == "true" ]; then
            echo "::debug::Current version in CITATION.cff: '${CURRENT_VERSION}'"
            echo "::debug::Current date in CITATION.cff: '${CURRENT_DATE}'"
          fi
      - name: Check if update is needed
        id: check_update
        run: |
          CURRENT_VERSION="${{ steps.parse_citation.outputs.current_version }}"
          CURRENT_DATE="${{ steps.parse_citation.outputs.current_date }}"
          TAG_VERSION="${{ steps.tag_info.outputs.tag_version }}"
          TAG_DATE="${{ steps.tag_info.outputs.tag_date }}"
          INCREMENTED_TAG_NAME="${{ steps.tag_info.outputs.incremented_tag_name }}"

          echo "Comparing values:"
          echo "  Version: '${CURRENT_VERSION}' vs '${TAG_VERSION}'"
          echo "  Date: '${CURRENT_DATE}' vs '${TAG_DATE}'"

          if [ "${CURRENT_VERSION}" != "${TAG_VERSION}" ] || [ "${CURRENT_DATE}" != "${TAG_DATE}" ]; then
            # Check if incremented tag already exists
            if git rev-parse --verify "refs/tags/${INCREMENTED_TAG_NAME}" >/dev/null 2>&1; then
              echo "::error::Incremented tag ${INCREMENTED_TAG_NAME} already exists!"
              echo "::error::Cannot create new version. Please resolve tag conflicts manually."
              exit 1
            fi

            echo "needs_update=true" >> $GITHUB_OUTPUT
            echo "::notice::CITATION.cff needs updating - will create new version ${INCREMENTED_TAG_NAME}"

            # Create update summary with incremented version
            UPDATE_SUMMARY=""
            if [ "${CURRENT_VERSION}" != "${TAG_VERSION}" ]; then
              UPDATE_SUMMARY="${UPDATE_SUMMARY}- Version: ${CURRENT_VERSION} → ${{ steps.tag_info.outputs.incremented_version }}\n"
            fi
            if [ "${CURRENT_DATE}" != "${TAG_DATE}" ]; then
              UPDATE_SUMMARY="${UPDATE_SUMMARY}- Date: ${CURRENT_DATE} → ${TAG_DATE}\n"
            fi
            echo "update_summary<<EOF" >> $GITHUB_OUTPUT
            echo -e "${UPDATE_SUMMARY}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "needs_update=false" >> $GITHUB_OUTPUT
            echo "::notice::CITATION.cff is already up to date"
          fi
      - name: Update CITATION.cff
        if: steps.check_update.outputs.needs_update == 'true'
        run: |
          INCREMENTED_VERSION="${{ steps.tag_info.outputs.incremented_version }}"
          TAG_DATE="${{ steps.tag_info.outputs.tag_date }}"

          # Create a backup
          cp CITATION.cff CITATION.cff.bak

          # Function to update or add a field
          update_field() {
            local field=$1
            local value=$2
            local file=$3

            if grep -q "^${field}:" "${file}"; then
              # Field exists, update it
              sed -i "s|^${field}:.*|${field}: ${value}|" "${file}"
              echo "Updated ${field} to: ${value}"
            else
              # Field doesn't exist, add it after cff-version if possible
              if grep -q "^cff-version:" "${file}"; then
                sed -i "/^cff-version:/a ${field}: ${value}" "${file}"
              else
                # Just append at the end
                echo "${field}: ${value}" >> "${file}"
              fi
              echo "Added ${field}: ${value}"
            fi
          }

          # Update fields with incremented version
          update_field "version" "${INCREMENTED_VERSION}" "CITATION.cff"
          update_field "date-released" "${TAG_DATE}" "CITATION.cff"

          # Show the diff
          echo "::group::Changes to CITATION.cff"
          diff -u CITATION.cff.bak CITATION.cff || true
          echo "::endgroup::"

          # Validate the updated file has correct values
          NEW_VERSION=$(grep -E '^version:' CITATION.cff | sed 's/version:[[:space:]]*//' | sed 's/^"//;s/"$//')
          NEW_DATE=$(grep -E '^date-released:' CITATION.cff | sed 's/date-released:[[:space:]]*//' | sed 's/^"//;s/"$//')

          if [ "${NEW_VERSION}" != "${INCREMENTED_VERSION}" ] || [ "${NEW_DATE}" != "${TAG_DATE}" ]; then
            echo "::error::Failed to update CITATION.cff correctly"
            echo "Expected version: ${INCREMENTED_VERSION}, got: ${NEW_VERSION}"
            echo "Expected date: ${TAG_DATE}, got: ${NEW_DATE}"
            mv CITATION.cff.bak CITATION.cff
            exit 1
          fi

          # Remove backup
          rm CITATION.cff.bak
      - name: Configure Git
        if: steps.check_update.outputs.needs_update == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
      - name: Commit changes
        if: steps.check_update.outputs.needs_update == 'true'
        id: commit
        run: |
          INCREMENTED_VERSION="${{ steps.tag_info.outputs.incremented_version }}"

          # Stage the changes
          git add CITATION.cff

          # Create commit message with proper formatting
          UPDATE_SUMMARY="${{ steps.check_update.outputs.update_summary }}"

          # Remove trailing newline from update summary if present
          UPDATE_SUMMARY="${UPDATE_SUMMARY%$'\n'}"

          # Construct commit message using printf to handle newlines properly
          if [ -n "${UPDATE_SUMMARY}" ]; then
            COMMIT_MSG=$(printf "chore: Update CITATION.cff to version %s\n\n%s\n\n[skip ci]" "${INCREMENTED_VERSION}" "${UPDATE_SUMMARY}")
          else
            COMMIT_MSG=$(printf "chore: Update CITATION.cff to version %s\n\n[skip ci]" "${INCREMENTED_VERSION}")
          fi

          # Commit the changes
          git commit -m "${COMMIT_MSG}"

          # Get the new commit hash
          NEW_COMMIT=$(git rev-parse HEAD)
          echo "new_commit=${NEW_COMMIT}" >> $GITHUB_OUTPUT
          echo "::notice::Created commit ${NEW_COMMIT}"
      - name: Create new tag
        if: steps.check_update.outputs.needs_update == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.CITATION_UPDATE_PAT || secrets.GITHUB_TOKEN }}
        run: |
          INCREMENTED_TAG_NAME="${{ steps.tag_info.outputs.incremented_tag_name }}"
          NEW_COMMIT="${{ steps.commit.outputs.new_commit }}"

          echo "::group::Creating new tag ${INCREMENTED_TAG_NAME} at ${NEW_COMMIT}"

          # Create the new incremented tag at the new commit
          git tag -a "${INCREMENTED_TAG_NAME}" "${NEW_COMMIT}" -m "Release ${INCREMENTED_TAG_NAME}"

          # Push the commit to the main branch
          git push origin HEAD:main || {
            echo "::error::Failed to push commit to main branch"
            exit 1
          }

          # Push the new tag
          git push origin "${INCREMENTED_TAG_NAME}" || {
            echo "::error::Failed to push new tag"
            exit 1
          }

          echo "::endgroup::"
          echo "::notice::Successfully created new tag ${INCREMENTED_TAG_NAME} at commit ${NEW_COMMIT}"
      - name: Create job summary
        if: always()
        run: |
          echo "## CITATION.cff Update Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.check_update.outputs.needs_update }}" == "true" ]; then
            echo "### ✅ Update Applied" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following changes were made:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.check_update.outputs.update_summary }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**New Tag**: \`${{ steps.tag_info.outputs.incremented_tag_name }}\` has been created with the updated CITATION.cff." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Original Tag**: \`${{ steps.tag_info.outputs.tag_name }}\` remains unchanged." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ℹ️ No Update Required" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The CITATION.cff file already contains the correct information:" >> $GITHUB_STEP_SUMMARY
            echo "- **Version**: ${{ steps.parse_citation.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Date Released**: ${{ steps.parse_citation.outputs.current_date }}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Triggered by tag: \`${{ steps.tag_info.outputs.tag_name }}\`*" >> $GITHUB_STEP_SUMMARY
